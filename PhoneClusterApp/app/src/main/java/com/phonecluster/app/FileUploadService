package com.phonecluster.app.services

import android.content.Context
import android.util.Base64
import com.phonecluster.app.api.ApiClient
import com.phonecluster.app.api.CompleteUploadRequest
import com.phonecluster.app.api.StartUploadRequest
import com.phonecluster.app.storage.PreferencesManager
import com.phonecluster.app.utils.FileChunk
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

class FileUploadService {

    data class UploadProgress(
        val currentChunk: Int,
        val totalChunks: Int,
        val bytesUploaded: Long,
        val totalBytes: Long,
        val percentage: Float
    )

    data class UploadResult(
        val success: Boolean,
        val fileId: Int?,
        val message: String,
        val uploadedChunks: Int
    )

    /**
     * Upload a file in chunks to the server
     */
    suspend fun uploadFile(
        context: Context,
        fileName: String,
        fileSize: Long,
        mimeType: String?,
        chunks: List<FileChunk>,
        onProgress: (UploadProgress) -> Unit = {}
    ): UploadResult = withContext(Dispatchers.IO) {
        try {
            val deviceId = PreferencesManager.getDeviceId(context) ?: -1
            val userId = 1  // TODO: Get from actual user session

            if (deviceId == -1) {
                return@withContext UploadResult(
                    success = false,
                    fileId = null,
                    message = "Device not registered",
                    uploadedChunks = 0
                )
            }

            // Step 1: Start file upload session
            val startRequest = StartUploadRequest(
                user_id = userId,
                device_id = deviceId,
                file_name = fileName,
                file_size = fileSize,
                file_type = mimeType,
                num_chunks = chunks.size
            )

            val startResponse = ApiClient.api.startFileUpload(startRequest)

            if (!startResponse.isSuccessful || startResponse.body()?.success != true) {
                return@withContext UploadResult(
                    success = false,
                    fileId = null,
                    message = "Failed to start upload: ${startResponse.message()}",
                    uploadedChunks = 0
                )
            }

            val fileId = startResponse.body()!!.file_id
            var uploadedChunks = 0
            var bytesUploaded = 0L

            // Step 2: Upload each chunk
            for (chunk in chunks) {
                try {
                    // Convert chunk data to Base64
                    val base64Data = Base64.encodeToString(
                        chunk.data,
                        Base64.NO_WRAP
                    )

                    // Upload chunk
                    val chunkResponse = ApiClient.api.uploadChunk(
                        fileId = fileId,
                        chunkIndex = chunk.index,
                        chunkData = base64Data
                    )

                    if (chunkResponse.isSuccessful && chunkResponse.body()?.success == true) {
                        uploadedChunks++
                        bytesUploaded += chunk.size

                        // Report progress
                        onProgress(
                            UploadProgress(
                                currentChunk = uploadedChunks,
                                totalChunks = chunks.size,
                                bytesUploaded = bytesUploaded,
                                totalBytes = fileSize,
                                percentage = (uploadedChunks.toFloat() / chunks.size) * 100
                            )
                        )
                    } else {
                        return@withContext UploadResult(
                            success = false,
                            fileId = fileId,
                            message = "Failed to upload chunk ${chunk.index}: ${chunkResponse.message()}",
                            uploadedChunks = uploadedChunks
                        )
                    }
                } catch (e: Exception) {
                    return@withContext UploadResult(
                        success = false,
                        fileId = fileId,
                        message = "Error uploading chunk ${chunk.index}: ${e.message}",
                        uploadedChunks = uploadedChunks
                    )
                }
            }

            // Step 3: Complete upload
            val completeResponse = ApiClient.api.completeFileUpload(
                CompleteUploadRequest(fileId = fileId)
            )

            if (completeResponse.isSuccessful && completeResponse.body()?.success == true) {
                return@withContext UploadResult(
                    success = true,
                    fileId = fileId,
                    message = "File uploaded successfully",
                    uploadedChunks = uploadedChunks
                )
            } else {
                return@withContext UploadResult(
                    success = false,
                    fileId = fileId,
                    message = completeResponse.body()?.message ?: "Failed to complete upload",
                    uploadedChunks = uploadedChunks
                )
            }

        } catch (e: Exception) {
            return@withContext UploadResult(
                success = false,
                fileId = null,
                message = "Upload failed: ${e.message}",
                uploadedChunks = 0
            )
        }
    }

    /**
     * Check upload status for a file
     */
    suspend fun checkFileStatus(fileId: Int) = withContext(Dispatchers.IO) {
        try {
            val response = ApiClient.api.getFileStatus(fileId)
            response.body()
        } catch (e: Exception) {
            null
        }
    }
}